<!doctype html>
<html lang="en">

	<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
        <title>Object-oriented JavaScript</title>
    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/white.css" id="theme">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/zenburn.min.css">
        
        <link rel="stylesheet" href="./fontawesome-6.2.0/css/all.min.css">
        <link rel="stylesheet" href="./style.css">
    
        <script src="print.js"></script>
    </head>

	<body>

		<div class="reveal">
			<div class="slides">
                <section>
                    <section data-background="#333333">
                        <h2>Web</h2>
                        <h1>Async, HTTPS, Cookies and Sessions</h1>
                        <p>Bertil Chapuis</p>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ## <i class="fas fa-tasks"></i> Overview of Today's Class
                            - Quiz about last week's lecture
                            - HTTPS
                            - Cookies and Sessions
                            - Authentication and Authorization
                            - Projects
                        </textarea>
                    </section>
                </section>

                <section>
                    <section data-background="#333333">
                        <h2><i class="fas fa-question-circle"></i> Quiz</h2>
                    </section>
                    <section data-markdown style="font-size: 0.65em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Question 1                        
                            Parmi les architectures suivantes, la ou lesquelles gardent une connexion ouverte?
                            - Polling
                            - Long-Polling
                            - Server-Sent Events
                            - WebSocket
                            - Aucune réponse correcte
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.65em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Question 2
                            Cochez les affirmations correctes à propos de l'API EventStream (SSE).
                            - Lorsque le serveur ferme la connexion, le navigateur essaie de se reconnecter automatiquement.
                            - Lorsque le navigateur ferme la connexion, le serveur essaie de se reconnecter automatiquement.
                            - Un méchanisme de callback permet d'observer l'état de la connexion ('open', 'close').
                            - Le navigateur transmet les message au serveur à l'aide du 'Chunked transfer encoding'.
                            - Aucune affirmation correcte
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.65em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Question 3
                            Vous souhaitez implémenter une stratégie de type Long-Polling pour communiquer avec un serveur (`www.example.com`). Parmi les programmes suivant, lequel implémente cette stratégie?
                            
                            - ```
                            var conn = new EventStream("http://www.example.com");
                            ```
                            - ```
                            setInterval(function () { 
                                fetch("http://www.example.com")
                                    .then(doSomething) 
                            }, 1000);
                            ```
                            - ```
                            var conn = new WebSocket("http://www.example.com");
                            ```
                            - ```
                            function get() {
                                fetch("http://www.example.com")
                                    .then(() => { doSomething(); get(); })
                            };
                            ```
                        </textarea>
                    </section>
                </section>

                <section>
                    <section data-background="#333333">
                        <h2><i class="fab fa-js"></i> Asynchronous Programming</h2>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Synchronous vs Asynchronous Programming

                            ### Synchronous Programming

                            Things happen **sequentially**, one at a time.
                            
                            Long-running actions are **blocking**: the program stops until the action has finished.

                            ### Asynchronous Programming

                            Things happen **in parallel**, multiple at the same time.
                            
                            Long-running actions are **non-blocking** : they are started in the background while the program continues to run.

                            When the background action has completed, two approaches:

                            - The program was waiting and gets the result back *(e.g. `await`)*
                            - The action was given a callback decsribing the next action *([Continuation-Passing Style](https://bessiambre.medium.com/continuation-passing-style-patterns-for-javascript-5528449d3070))*

                            Notes:
                            
                            See also **Eloquent Javascript** - https://eloquentjavascript.net/11_async.html#h_HH3wvnWMnd

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Multi-thread synchronous *vs* asynchronous
                            
                            **Multi-threaded synchronous model**: multiple synchronous threads in parallel. Long-running actions remain **blocking**: the time they take to execute is part of the timeline. 
                            
                            **Asynchronous model**: long-running actions can be **non-blocking**. A **fork** occurs in the timeline: the program continues while the long-running action runs in the background.

                            <img src="images/async.svg" />

                            When the long-running action terminates, it uses a **callback** function to continue the execution of the program.

                            **Eloquent Javascript** - https://eloquentjavascript.net/11_async.html#h_HH3wvnWMnd
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> The Event Loop
                            
                            In JavaScript, **asynchronous actions** are put in a **message queue** which is part of the runtime environment.

                            <img src="images/event-loop-queue.png" style="width: 30%;" />

                            The **message queue** is a list of **asynchronous actions** to be processed by the **event loop**. 
                            
                            ```js
                            // The Event Loop, pseudocode
                            while (queue.waitForMessage()) {
                              queue.processNextMessage();
                            }
                            ```

                            When processing messages, the **event loop** initializes a **stack** dedicated to the execution of the **asynchronous action**.
                            Upon termination, the event loop notifies the main program through a mechanism of **callbacks**.

                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fas fa-hand-paper"></i> Example!
                            
                            In browsers, `setTimeout`, `setInterval`, event listeners and HTTP requests, typically append messages to the **message queue** of the runtime.
                            
                            What is the output produced by the following programm?

                            ```js
                            setTimeout(function() {
                                console.log("a")
                            }, 10);
                            
                            console.log("b");

                            setTimeout(function() {
                                console.log("c");
                            }, 20);

                            console.log("d");
                            ```
                            
                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop

                            Notes:

                            - `setTimeout` takes a callback and a delay as arguments, and executes that callback after that delay.
                            - `SetInterval` takes a callback and a delay as arguments, and executes that callback every time that delay passes.

                        </textarea>
                    </section>

                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Callback Hell

                            Asynchronous programming with callbacks can result in a so-called **callback hell**.
                            
                            ```js
                            function countDown(arg, callback) {
                                console.log(arg);
                                setTimeout(callback, 1000);
                            }
                            
                            countDown("five...", function() {
                                countDown("four...", function() {
                                    countDown("three...", function() {
                                        countDown("two...", function() {
                                            countDown("one...", function() {
                                                console.log("fire!!!");
                                            });
                                        });
                                    });
                                });
                            });
                            ```

                            The introduction of **asynchronous programming** constructs in the JavaScript language (such as `Promise`, `async`, `await`) helps at adressing this issue.
                            
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Promise

                            A `Promise` represents the eventual completion (or failure) of an **asynchronous** operation, and its resulting value.
                            In other words, a `Promise` is a proxy for a value that is not necessarily known when the promise is created.
                            
                            ```js
                            var promise = Promise.resolve("Hello, World!");
                            ```
                            
                            A `Promise` is in one of these states:
                            
                            - `pending`: initial state, neither fulfilled nor rejected.
                            - `resolved`: meaning that the operation completed successfully.
                            - `rejected`: meaning that the operation failed.
                            
                            A promise is said to be `settled` if it is either `resolve` or `rejected`.
                            
                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
                            
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Promise

                            The constructor of a promise receives an `executor`, a function that is passed with the arguments `resolve` and `reject`.
                            `resolve` and `reject` are functions that can be used to `settle` the promise.
                            
                            ```js
                            let promise = new Promise(function(resolve, reject) {
                              setTimeout(function() {
                                if (Math.random() > 0.5) {
                                    resolve(42); 
                                } else {
                                    reject("The ultimate question to life, the universe and everything has no answer!")
                                } 
                              }, 1000);
                            });
                            ```
                            
                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Promise "chaining"

                            Methods `then` and `catch` on `Promise` allow us to "map" the settlement of a promise, i.e. provide a function to be applied on it.

                            - `then` takes two functions, to be applied to the eventual resolution or failure of the promise.
                            - `catch` takes a single function to be applied to the eventual failure of the promise.

                            These functions return a new Promise, allowing to chain them.

                            ```js
                            promise.then(value => console.log(value)).catch(reason => console.error(reason));
                            ```

                            <img src="images/js_promises.png" style="width: 60%;" />
                            
                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
                            
                            Notes:

                            In theory of programming languages, a `map` is an operation on a wrapper object that applies a modifier function to the wrapped object(s). A `map` is often thought of is the context of collections, where the function is applied to all elements of the collection, but it is also applicable to many other contexts: we can "map" the content of an `Optional` in Java, or the resolution of a `Promise` in JavaScript.
                            
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Promise Helpers

                            The `Promise` object comes with useful helper methods, all returning a new promise.
                            
                            - `Promise.all(iterable)` resolves when all resolve, and rejects when any rejects.
                            - `Promise.allSettled(iterable)` resolves when all resolve (and never rejects).
                            - `Promise.race(iterable)` settles like the earliest promise to settle.
                            - `Promise.resolve(value)` and `Promise.reject(reason)` return already settled promises.
                            - `Promise.any(iterable)` resolves when any resolve, and rejects when all reject.
                            
                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
                            
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Asynchronous functions and waiting

                            #### **Waiting for settlement**
                            
                            The `await` keyword, followed by a promise, blocks until it is settled, and then evaluates to the resolution value of the promise.

                            #### Asynchronous functions

                            Only **asynchronous functions** are allowed to `await` a promise. They are defined with the `async` keyword.

                            ```js
                            function deepThought() {
                                return new Promise(function(resolve, reject) {
                                    setTimeout(function() {
                                        if (Math.random() > 0.5) resolve(42); 
                                        else reject("The ultimate question to life, the universe and everything has no answer!");
                                    }, 1000);
                                });
                            }
                            
                            async function asyncFunction() {
                                return await deepThought();
                            }

                            let promise = asyncFunction();
                            ```
                            
                            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function

                            Notes:

                            Note that the execution of a promise begins as soon as the promise is created, not when it is awaited.
                            
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-hand-paper"></i> Hands on!

                            Get rid of the callback hell by making the `countDown` asynchronous.
                            
                            ```js
                            function countDown(arg, callback) {
                                console.log(arg);
                                setTimeout(callback, 1000);
                            }
                            
                            countDown("five...", function() {
                                countDown("four...", function() {
                                    countDown("three...", function() {
                                        countDown("two...", function() {
                                            countDown("one...", function() {
                                                console.log("fire!!!");
                                            });
                                        });
                                    });
                                });
                            });
                            ```
                            
                            Notes:

                            <div class="spoiler">

                            Solution:

                            ```js

                            function countDown(arg) {
                                return new Promise(function(resolve, reject) {
                                    console.log(arg);
                                    setTimeout(resolve, 1000);
                                });
                            }
                            countDown("five...")
                                .then(function() { return countDown("four..."); })
                                .then(function() { return countDown("three..."); })
                                .then(function() { return countDown("two..."); })
                                .then(function() { return countDown("one..."); })
                                .then(function() { console.log("fire!!!"); });

                            ```
                                
                            </div>

                        </textarea>
                    </section>
                </section>
                
                <section>
                    <section data-background="#333333">
                        <h2><i class="fab fa-js"></i> Asynchronous Network Programming</h2>
                    </section>
                    <section data-markdown style="font-size: 0.75em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> XMLHTTPRequest
                            
                            `XMLHTTPRequest` is used to interact with servers without having to do a full page refresh.

                            It loads content **asynchronously** using callbacks. *An asynchronous call executes in the background without affecting what the user is doing*.

                            ```js
                            var url = 'https://api.github.com/users/web-classroom';
                            var request = new XMLHttpRequest();
                            request.open('GET', url);
                            request.responseType = 'json';
                            request.onload = function() {
                                console.log(request.getAllResponseHeaders());
                                console.log(request.status); // The HTTP status code
                                console.log(request.response); // The response body
                            }
                            request.onerror = // ...
                            requset.ontimeout = // ...
                            request.onprogress = // ...
                            request.send();
                            ```
                            
                            Can be used to load JSON and other formats, and not only XML, despite its name.
                            
                            <span class="detail">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON</span>

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> Fetch API

                            The Fetch API provides an interface for fetching resources across the network. It provides a more powerful and flexible feature set than `XMLHttpRequest`.

                            By default, `fetch` performs GET requests and returns a `Promise`.

                            ```js
                            var promise = fetch('https://api.github.com/users/web-classroom');
                            console.log(promise);
                            ```

                            Additional parameters enables to change the method (HEAD, POST, PUT, etc.) and add headers.

                            ```js
                            var promise = fetch("https://api.github.com/users/web-classroom", {
                                method: `POST`,
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({'value': 'Hello, World!' })
                            });
                            console.log(promise);
                            ```

                            https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
                            
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fab fa-js"></i> NodeJS HTTP client

                            NodeJS provides an HTTP client that relies on a callback mechanism.

                            ```js
                            const https = require('https');

                            const req = https.get('https://api.github.com/users/web-classroom',
                                { headers: { 'User-Agent': 'NodeJS' } },
                                res => {
                                    var body = '';
                                    res.on('data', chunk => {
                                        body += chunk;
                                    })
                                    res.on('end', function () {
                                        console.log(body);
                                    });
                                });

                            req.end()
                            ```

                            [Axios](https://github.com/axios/axios) provides a uniform promise based HTTP client for the browser and the server.

                        </textarea>
                    </section>
                </section>
                
                <section>
                    <section data-background="#333333" style="font-size: 0.8em;">
                        <h2><i class="fa-solid fa-lock"></i> HTTPS</h2>
                    </section>

                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            # <i class="fas fa-network-wired"></i> Internet's Conceptual Model

                            <img alt="Networking" src="images/network_reminder.svg" style="width: 80%;" />

                            Providing encryption at the level of the transport layer (SSL/TLS) makes communication security transparent to the application developers (e.g. HTTP becomes HTTPS).

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            # <i class="fas fa-lock"></i> SSL/TLS

                            - Operates on top of the transport protocol (TCP)
                            - Implements a socket interface
                            - Relies on a handshake protocol based on digital certificates to generate session key
                            - Provides:
                                - **Confidentiality** of the data
                                - **Integrity** of the data
                                - **Authentication** of the server
                        
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-lock"></i> Digital certificates (1)

                            - Bound to a <i class="fas fa-globe"></i> hostname;
                            - Contain a <i class="fas fa-key"></i> public key;
                            - Contain a proof that the owner of the hostname holds the private key;
                            - Valid for a certain <i class="far fa-calendar-times"></i> period;
                            - Issued and signed <i class="fas fa-signature"></i> by a certification authority (CA) <i class="fas fa-building"></i>;
                            - Operating systems shipped with a list of trusted CA certificates;
                            - Etc.

                            <i class="fas fa-hand-paper"></i> On your computer, where is the list of trusted cerificates?

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fas fa-lock"></i> Digital certificates (2)

                            <img src="images/certificate.png" alt="certificate" style="width: 50%" />

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            # <i class="fas fa-lock"></i> TLS Connection

                            <i class="fas fa-hand-paper"></i> [The illustrated TLS Connection](https://tls.ulfheim.net/)

                            Overall, SSL/TLS operates as follow:
                            - The clients connects to the server and describes its capabilities (i.e., the ciphers it supports) and a random number;
                            - The server chooses a cipher (e.g., TLS_RSA_WITH_3DES_EDE_CBC_SHA) and sends back its choice of cipher, its certificate and a random number;
                            - The client checks the certificate;
                            - Both derive a session key from the two random numbers and exchange the hashes of the initial handshake messages.

                            

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            # <i class="fas fa-lock"></i> Let's Encrypt and ACME

                            <img src="images/letsencrypt.svg" alt="letsencrypt"  style="height: 60px" />

                            **Let's Encrypt** is a non-profit certificate authority run by Internet Security Research Group that provides X.509 certificates for Transport Layer Security encryption at no charge. 


                            <img src="images/acme.png" alt="letsencrypt"  style="height: 100px" />

                            The **Automatic Certificate Management Environment (ACME)** protocol is a communications protocol for automating interactions between certificate authorities and their users' web servers, allowing the automated deployment of public key infrastructure at very low cost. It was designed by the Internet Security Research Group (ISRG) for their Let's Encrypt service.

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            # <i class="fas fa-hand-paper"></i> Developing with certificates?

                            mkcert is a simple tool for making locally-trusted development certificates. It requires no configuration.

                            It creates and installs a local CA in the system root store, and generates locally-trusted certificates.

                            https://github.com/FiloSottile/mkcert

                            Give it a try by playing with the `example-mkcert` repository.

                        </textarea>
                    </section>

                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Questions
                        </textarea>
                    </section>

                </section>

                

                <section>
                    <section data-background="#333333">
                        <h2><i class="fas fa-cookie-bite"></i> Cookies and Sessions</h2>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-cookie-bite"></i> Cookies

                            A cookie is a small piece of data sent from a website and stored by the user's web browser while the user is browsing.

                            The browser sends the cookie back to the server with each subsequent request to the same server. This allows the server to identify and track the web browser.

                            Cookies are mainly used for three purposes:
                            - Tracking
                            - Personalization
                            - Session management

                            Cookies can be used to remember state information. 

                            https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fas fa-cookie-bite"></i> HTTP Headers

                            <img src="images/http_cookie.svg" alt="polling" style="width:400px;" />

                            The `Set-Cookie` HTTP response header is used to send cookies from the server to the user agent.

                            ```http
                            Set-Cookie: <cookie-name>=<cookie-value>; <cookie-name>=<cookie-value></cookie-value>
                            ```

                            The browser will send back all previously stored cookies to the server in the `Cookie` HTTP request header.

                            ```http
                            Cookie: <cookie-name>=<cookie-value>; <cookie-name>=<cookie-value>
                            ```
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.6em;">
                        <textarea data-template>
                            ## <i class="fas fa-cookie-bite"></i> HTTP Headers

                            A cookies without `Expires` is called a session cookie, i.e., it is deleted when the client shuts down.

                            ```http
                            Set-Cookie: cookie=choco
                            ```

                            A cookie with `Expire` set to a date or set to `Max-Age` will survive the client's session.

                            ```http
                            Set-Cookie: cookie=choco; Expires=Wed, 21 Oct 2020 07:28:00 GMT;
                            ```

                            The cookie can be made inaccessible to JavaScript with the `HttpOnly` directive.

                            ```http
                            Set-Cookie: cookie=choco; HttpOnly
                            ```

                            It is also possible to require the HTTPS protocol for transmitting cookies with the `Secure` directive.

                            ```http
                            Set-Cookie: cookie=choco; Secure
                            ```

                            https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fas fa-cookie-bite"></i> Setting Cookies from the Client

                            It is possible to access the cookie from the same origin with javascript.

                            ```js
                            var cookie = document.cookie;
                            ```

                            Similarly, the value of the cookie can be modified from JavaScript.

                            ```js
                            document.cookie = "another_cookie=more_choco";
                            ```

                            https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie

                        </textarea>
                    </section>

                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fas fa-cookie-bite"></i> Cookies and cross origin requests

                            By default, when you include a resource from a different domain in your Web page, the cookies initiated by this domain will be included in the request.

                            In order to preserve privacy, you can set the `crossorigin` attribute in your HTML elements.

                            ```
                            <script src="https://example.com/example-framework.js" crossorigin="anonymous"></script>
                            ```

                            <i class="fas fa-hand-paper"></i> What happen when you integrate social media buttons to your website?

                        </textarea>
                    </section>
                    
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Questions
                        </textarea>
                    </section>
                </section>

                <section>
                    <section data-background="#333333">
                        <h3><i class="fas fa-user-friends"></i> Authentication and Authorization</h3>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-user-friends"></i> Authentication and Authorization

                            In a web application, **authentication** is the process of verifying who a user is, while **authorization** is the process of verifying what they have access to.

                
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-user-friends"></i>Authentication Mechanisms

                            The Web provides a plethora of authentication methods:
                            
                            - Cookies and sessions
                            - `Authentication` Header
                                - HTTP basic
                                - HMAC token
                                - JWT token
                                - Bearer token
                            - `X-API-Key` Header
                            - [OAuth2](https://oauth.net/2/)
                            - [WebAuthN](https://webauthn.io/)
                            - etc.
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fas fa-user-friends"></i> One size does not fit all!

                            The choice of an authentication method typically varies depending on:

                            - The kind of entity you authenticate (Human or Machine)
                            - The kind of service you provide (API or Web Application)
                            - The kind of web application you devise (SPA or MPA)
                            - The needs in terms of security (immediate revokation, time-to-live, etc.)
                            - The needs in terms of scalability (number of users, number of requests, etc.)
                            - The needs in terms of user experience (login, logout, etc.)
                            - etc.

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-user-friends"></i> Authorization Mechanisms

                            In Web applications, authorization mechanisms often rely on the notions of:
                            - Roles (admin, editor, user)
                            - Ownership (does this resource, object or attribute belong to that user)

                            In practice, authorization mechanisms are often hard-coded, which gives a lot of flexibility.
                            However, it is also possible to rely on authorisation patterns, such as:

                            - [Access-Control List (ACL)](https://en.wikipedia.org/wiki/Access-control_list)
                            - [Role-based access control (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control)
                            - [Attribute-based access control (ABAC)](https://en.wikipedia.org/wiki/Attribute-based_access_control)

                            In ExpressJS, the [express-acl](https://www.npmjs.com/package/express-acl) and [express-rbac](https://www.npmjs.com/package/express-rbac) packages provides authorization middlewares.

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fas fa-hand-paper"></i> Learn more about JSON Web Token (JWT)
                            
                            ```http
                            Authorization: Bearer <token>
                            ```

                            Try to answer the following questions:
                            - Can JWT be used for Authentication?
                            - Can JWT be used for Authorization?
                            - Why is JWT often refered to as a scalable method?
                            - Can a JWT token be easily revoked?
                            - Would you use JWT tokens for authenticating computers that perform API calls?

                            https://jwt.io/
                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fas fa-hand-paper"></i> Learn more about OAuth2

                            https://auth0.com/docs/api-auth/which-oauth-flow-to-use

                            Try to answer the following questions:
                            - What kind of Access Token does OAuth2 use?
                            - Why does OAuth2 introduced the notion of Flow?
                            - Can OAuth2 be used to authenticate the users of an MPA?
                            - Can OAuth2 be used to authenticate the users of an SPA?

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            ## <i class="fas fa-hand-paper"></i> Configure an Authentication Middleware

                            Clone the `example-passport` repository from the `web-classroom` organization.

                            https://github.com/web-classroom/example-passport

                            It illustrates how:
                            - Local authentication can be configured in express with [Passport](http://www.passportjs.org/)
                            - Github can be used for authentication (via oauth2)
                            - An attacker can impersonate users with CSRF
                            - A website can be protected from CSRF attacks

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Questions
                        </textarea>
                    </section>
                </section>

                <section>
                    <section data-background="#333333">
                        <h2><i class="fab fa-js"></i> Projet</h2>
                    </section>
                    <section data-markdown style="font-size: 0.7em;">
                        <textarea data-template>
                            # <i class="fa fa-tasks"></i> Projet

                            Implémenter et documenter **deux améliorations** au jeu vidéo.

                            Exemples:
                            - Faire le rendu du jeu avec WebGL avec [threejs](https://threejs.org/)
                            - Communiquer en P2P avec WebRTC avec [peerjs](https://peerjs.com/)
                            - Utiliser [TensorFlow JS](https://www.tensorflow.org/js/demos) pour controller le jeu avec la webcam 
                            - Faire un score board avec Vue ou React
                            - Implémenter une IA

                            Les améliorations doivent être décrites et validées dans un délai de deux semaines.

                            ### Soyez créatifs... ;)

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## <i class="fas fa-question-circle"></i> Questions
                        </textarea>
                    </section>
                </section>
            </div>
		</div>

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/markdown/markdown.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.js"></script>
        <script src="./script.js" type="module"></script>

	</body>
</html>
